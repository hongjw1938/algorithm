- Scanner
	- scanner의 경우 close를 제대로 해주지 않으면 끝나지 않는 듯.
	- scanner의 경우 string을 읽고 싶다면 next(); 를 사용
- BufferedReader, BufferedWriter
	- 사용 권장
- StringBuffer
	- 만약 substring을 해서 비교를 하고 싶다면 비교 대상도 반드시 toString으로 String형으로 변경 할 것.
- 주의
	- 자료구조를 static이나 instance로 선언하였다면 테스트 케이스를 실행할 때마다 누적된다는 것을 기억해야한다.
	- 반드시 테스트케이스마다 초기화할 것.
- 입력값을 읽는 방법
	- Scanner 혹은 BufferedReader를 통해 읽어낸다.
	- 필요한 부분을 잘라내고 반복문을 취하고 싶은 경우, String으로 전체 Line을 읽어낸 다음 split시킬 수 있다. == String.split(" ");
	- 혹은 StringTokenizer를 이용하여 token별로 값을 넣어서 사용할 수 있다.
- string split : .으로는  split이 안되는듯??
- Comparator사용하여 ArrayList 정렬 : Q4_0829.java참조
- 값이 null인지 확인할 때는 equals가 아니라 == 으로 비교한다.
- BFS 문제는 Contact 알고리즘을 확인한다.
	- 연락망에서 현재 연락자를 기존 Queue(A)에서 빼고 다른 큐(B)에 넣는다.
	- 기존 큐에는 현재 연락자가 연락하는 인원을 추가한다. 이 때, 자동으로 연락이 가기 때문에 그 인원들도 모두 연락상태로 지정해야 한다.
	- 현재 연락자가 연결하는 인원들을 전부 A에 추가되었으며, A에 들어있다는 것은 연락중이 아니었다는 의미이므로 마지막으로 연락을 받는 인원이 아니다.
	- 그렇다는 것은, A에 추가된 인원들도 다른 여타 인원에게 연락이 가능한지 살펴야 한다.
	- 따라서, A가 비어있지 않다면 B는 전부 clear 시켜야 한다.
	- 만약 A가 비어있다면, 현재 시점 연락자들이 전부 B에 들어있을 것이다.
	- B에 있는 인원 중 가장 번호가 큰 사람을 반환한다.
- 우선순위 큐(PriorityQueue)
	- 일반적으로 Queue라는 자료구조는 '선입선출'(First-In, First-Out)의 대기열 규칙(queuing discipline)을 가지고 있다. 말그대로 먼저들어온 놈이 먼저 나간다는 것이다.하지만 JAVA에서 제공하는 'PriorityQueue'는 우선순위를 결정하여 들어온 순서와 상관없이 그 우선순위가 높은 엘리먼트가 나가게 된다.
	- Comparator 인터페이스를 구현하여 어떻게 offer할지 지정한다.
	- 만약 기존에 만들어놓은 queue에서 순서만 바꿔 새로 넣고 싶다면 Collections.reversedOrder를 사용한다.
- WormMatching 알고리즘 : 일반적인 dfs문제와 다를 것이 없다.
- chemicalbottlematrix : 내가 푼 방식은 큐에 넣고 계속해서 빼는 방식이었지만, 다른 사람의 코드가 더 좋음. 해당 코드는 반복문으로 다 돌면서 0이 아니면 주변을 다 조사하여 강제로 0으로 만들고 재조사하는 방식.
- ProjectHanaro : 터널의 길이를 조사하여 우선 모든 길이를 첫 번째 섬과의 기준으로 잡아 연결한다고 가정한다.
	- 그 다음, 방문하지 않은 노드를 조사하여 해당 노드를 기준으로 다른 노드와의 거리를 계산하고 그 거리가 기존보다 짧다면 해당 거리를 저장한다.
	- 이를 N회 반복(0번 섬부터 시작하기 때문)
	